/*
 * Copyright (C) <2009> <Quinn Snell, Mark Clement>
 *
 * This program is free software; you can redistribute it and/or modify it under the 
 * terms of the GNU General Public License as published by the Free Software Foundation; 
 * either version 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with this program (gpl.txt); 
 * if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * More information can be obtained by accessing http://dna.cs.byu.edu/psoda
 */
#include "BootstrapInstr.h"
#include "Interpreter.h"
#include "Dataset.h"
#include "Environment.h"
#include "QTreeRepository.h"
#include "QTree.h"
#include "Dist.h"
#include "NJ.h"
#include "RF.h"
#include "HSearchInstr.h"
#include <iostream>

using namespace std;

BootstrapInstr::BootstrapInstr() : BuiltInCommand() {
  setDescription("Perform Bootstrap. Randomly reweight columns of the alignment matrix and calculate the optimal tree based on that reweighting.  Then generate a consensus based on all of the trees generated by reweightings");
  initDefaultValue("bseed", "clock", "Random number generator seed. Default is seed from clock");
  initDefaultValue("blocksize", 10, "Bootstrap block size for dependent columns");
  initDefaultValue("nreps", 100, "Number of replicates (Number of times to reweight)." );
  initDefaultValue("search", "heuristic", "Search Strategy to use.  Heuristic uses TBR, nj=Neighbor Joining, upgma=Unweighted Pair Group Method using Arithmetic Averages");
  addParamOption("search", "nj");
  addParamOption("search", "upgma");
  initDefaultValue("conlevel", 50, "Confidence Level for boostrap consensus");
  initDefaultValue("keepall", "no", "Keep all trees? (Not currently implemented)");
  addParamOption("keepall", "yes");
  initDefaultValue("wts", "simple", "Not currently implemented");
  addParamOption("wts", "ignore");
  addParamOption("wts", "repeatcnt");
  addParamOption("wts", "proportional");
  initDefaultValue("nchar", "current", "The number of characters to reweight.  A value of current reweights all columns");

  return;
}

BootstrapInstr::~BootstrapInstr() 
{
  return;
}

void BootstrapInstr::execute(Environment* baseEnv, Literal*& returnVal __attribute__((unused)) )
{
	execute(baseEnv);
}

void BootstrapInstr::execute(Environment* baseEnv ) 
{
    QTree *qt;
    int nchars;
    Dataset *dset = Interpreter::getInstance()->dataset();

    if (baseEnv->lookupString("nchar") == "current")
        nchars = dset->nchars();
    else
        nchars = baseEnv->lookup("nchar").toInt();

    int *weights = dset->weights();

    // Seed the random number generator
    int seed = 0;
    //seed with the current clock
    seed = time(NULL);

    const Literal& seedLit = baseEnv->lookup("bseed");
    if (StringLiteral::toLowerCase(seedLit.toString()) != "clock") {
      seed = seedLit.toInt();
    }

    srandom(seed);

    // Create a new TreeRepository so we don't mess with the one we may already have
    QTreeRepository* allTrees = new QTreeRepository(false);
    QTreeRepository* somTrees = new QTreeRepository();



    // Run nreps times
    const Literal& nrepsLit = baseEnv->lookup("nreps");
    int nreps = nrepsLit.toInt();

	allTrees->setMaxTrees(INT_MAX, dset->ntaxa());

    string search = baseEnv->lookupString("search");

    for (int i = 0; i < nreps; i++)
    {   
        // Zero out the weights. The original weights should be stored in the dataset
        for (int j = 0; j < dset->nchars(); j++)
        {
            weights[j] = 0;
        }
        // Based on the options, randomly select columns of the matrix.
        for (int j = 0; j < nchars; j++)
        {
            int loc = random() % dset->nchars();
            weights[loc]++;
        }

        // Run the analysis 
        if (search == "heuristic")
        {
            //run hsearch
			HSearchInstr *hs = new HSearchInstr();
			hs->doHeuristicSearch(baseEnv,somTrees);
			delete hs;
        }
        else if (search == "nj")
        {
            //run nj search
			NJSearch *nj = new NJSearch();
			nj->search(*somTrees,NULL,NULL,1);
			delete nj;
        }
        else if (search == "upgma")
        {
            //run upgma search
            DistSearch *dist = new DistSearch();
            dist->search(*somTrees, NULL, NULL, 1);
			delete dist;
        }
        else
        {
            // the search type is not supported
        }
        
        //fprintf(stderr, "nreps: %d\n", nreps);
        //somTrees->printNewick(cerr);

        // Pull the trees out of the current repository and place them in the big one
		int iter = 0;
        while ((qt = somTrees->popTree()) != NULL)
        {
				iter++;
				//printf("Before Add to second repo\n");
				//qt->print();
			    allTrees->addTree(qt);
				//printf("Adding tree %d ",iter);
				//qt->print();
		}
		somTrees->removeAll();
    }
    // Now do a consensus across all the trees and present the consensus tree to the user
    RF *consensus = new RF(allTrees);
    int conlevel = baseEnv->lookup("conlevel").toInt();
    QTree *contree = consensus->consensus(conlevel/100.0); 
    fprintf(stderr, "All done with Bootstrap. Consensus Tree is: %s\n", contree->treeStr());
	contree->showTree();
	consensus->print();
    // Reset the weights of the dataset from the original weights
    dset->resetWeights();

    // Free up the allocated repositories
    allTrees->removeAll();
    delete allTrees;
    delete somTrees;

    return;
}

string BootstrapInstr::getName() const 
{
  return "bootstrap";
}
